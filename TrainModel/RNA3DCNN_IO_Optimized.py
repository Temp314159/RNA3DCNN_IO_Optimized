import numpy as np
import subprocess
import linecache
import sys
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten
from keras.layers import Conv3D, AveragePooling3D, MaxPooling3D
from keras.optimizers import SGD
from keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau, CSVLogger
from keras.models import load_model
from keras import regularizers
from keras.utils import Sequence

datapath='/home/yourfolder/data/'#put FilteredDataset and MDPDB under this path
VoxelPrg='/home/yourfolder/RNA3DCNN_IO_Optimized/Voxelizate/Voxelizate'
listpath='/home/yourfolder/list/datalist/'#same as ExtractList out_put_path
cppath='/home/yourfolder/out/'#check point
modelpath='/home/yourfolder/out/'

#t means train, v means validation.
tbatchsize=128
tsteps=7000

vbatchsize=256
vsteps=700

#Uncomment to extract list every time. (Nucleotide selected randomly, list different every time.)
'''
EListPrg='/home/yourfolder/RNA3DCNN_IO_Optimized/Voxelizate/ExtractList'
tpdblist='/home/yourfolder/list/tpdblist'
vpdblist='/home/yourfolder/list/vpdblist'

tlist=subprocess.call([EListPrg,tpdblist,datapath,listpath,'t'])
if tlist!=0:
	print("Extract tlist failed.")
	exit()
	
vlist=subprocess.call([EListPrg,vpdblist,datapath,listpath,'v'])
if vlist!=0:
	print("Extract vlist failed.")
	exit()

print("List extract finished. Start training.")
'''

#uncomment below lines to clean up files generated by last test.
'''
subprocess.call("rm -f "+modelpath+"*",shell=True)
subprocess.call("rm -f "+cppath+"*",shell=True)
'''

class tSequence(Sequence):
    def __init__(self, dpath, VoxelPrg, listpath, batchsize, steps):
        #initial param
        self.dpath = dpath
        self.VoxelPrg = VoxelPrg
        self.listpath = listpath
        self.batchsize = batchsize
        self.steps = steps

    def __len__(self):
        #sequence lenth
        return self.steps

    def __getitem__(self, index):
        lpath=self.listpath+'tdatalist'
        x = np.zeros((self.batchsize,3, 32, 32, 32))
        y = np.zeros((self.batchsize))
        num = 0
        numy = 0
        xydata = subprocess.Popen([self.VoxelPrg,self.dpath,lpath,str(index*self.batchsize+1),str(self.batchsize)],stdout=subprocess.PIPE)
        for i in range(index*self.batchsize+1,(index+1)*self.batchsize+1):
            liney = linecache.getline(lpath, i)
            a = liney.split()
            y[numy]=float(a[4])
            numy = numy+1
        #When testing, uncomment to get error messages from Voxelizate. (Meanwhile turn on error feedback in Voxelizate.)
        '''
        if xydata.poll() is not None:
            if xydata.poll() != 0:
                print(xydata.stdout)
                sys.exit()
        '''
        while True:
            line=xydata.stdout.readline()
            if line:
                line = bytes.decode(line)
                aa = line.split()
                num = int(aa[0])
                nmap = int(aa[1])
                xx = int(aa[2])
                yy = int(aa[3])
                zz = int(aa[4])
                xval = float(aa[5])
                x[num][nmap][xx][yy][zz] = xval
            else:
                if xydata.poll() is not None:
                    break
        x = x.astype('float32')
        y = y.astype('float32')
        x[:, 1] /= 31.0
        x[:, 2] += 1.0
        x[:, 2] /= 2.2
        z = self.tNewWeight(y)
        y /= 30.0
        return x, y, z

    def tNewWeight(self,y):
        try:
            z = np.ones(len(y), dtype='float32')
            idx = np.where(y <= 1.0)
            z[idx] = 4.94
            idx = np.where((y > 23.0) & (y <= 24.0))
            z[idx] = 1.16
            idx = np.where((y > 24.0) & (y <= 25.0))
            z[idx] = 1.43
            idx = np.where((y > 25.0) & (y <= 26.0))
            z[idx] = 1.73
            idx = np.where((y > 26.0) & (y <= 27.0))
            z[idx] = 2.38
            idx = np.where((y > 27.0) & (y <= 28.0))
            z[idx] = 3.51
            idx = np.where((y > 28.0) & (y <= 29.0))
            z[idx] = 5.0
            idx = np.where((y > 29.0) & (y <= 30.0))
            z[idx] = 7.96
        except Exception as e:
            print(e)
        else:
            return z

class vSequence(Sequence):
    def __init__(self, dpath, VoxelPrg, listpath, batchsize, steps):
        #initial param
        self.dpath = dpath
        self.VoxelPrg = VoxelPrg
        self.listpath = listpath
        self.batchsize = batchsize
        self.steps = steps

    def __len__(self):
        #sequence lenth
        return self.steps

    def __getitem__(self, index):
        lpath=self.listpath+'vdatalist'
        x = np.zeros((self.batchsize,3, 32, 32, 32))
        y = np.zeros((self.batchsize))
        num = 0
        numy = 0
        xydata=subprocess.Popen([self.VoxelPrg,self.dpath,lpath,str(index*self.batchsize+1),str(self.batchsize)],stdout=subprocess.PIPE)
        for i in range(index*self.batchsize+1,(index+1)*self.batchsize+1):
            liney = linecache.getline(lpath, i)
            a = liney.split()
            y[numy]=float(a[4])
            numy=numy+1
        #When testing, uncomment to get error messages from Voxelizate. (Meanwhile turn on error feedback in Voxelizate.)
        '''
        if xydata.poll() is not None:
            if xydata.poll() != 0:
                print(xydata.stdout)
                sys.exit()
        '''
        while True:
            line=xydata.stdout.readline()
            if line:
                line = bytes.decode(line)
                aa = line.split()
                num = int(aa[0])
                nmap = int(aa[1])
                xx = int(aa[2])
                yy = int(aa[3])
                zz = int(aa[4])
                xval = float(aa[5])
                x[num][nmap][xx][yy][zz] = xval
            else:
                if xydata.poll() is not None:
                    break
            num=num+1
        x = x.astype('float32')
        y = y.astype('float32')
        x[:, 1] /= 31.0
        x[:, 2] += 1.0
        x[:, 2] /= 2.2
        z = self.vNewWeight(y)
        y /= 30.0
        return x, y, z

    def vNewWeight(self,y):
        try:
            z = np.ones(len(y), dtype='float32')
            idx = np.where(y <= 1.0)
            z[idx] = 4.94
            idx = np.where((y > 23.0) & (y <= 24.0))
            z[idx] = 1.16
            idx = np.where((y > 24.0) & (y <= 25.0))
            z[idx] = 1.43
            idx = np.where((y > 25.0) & (y <= 26.0))
            z[idx] = 1.73
            idx = np.where((y > 26.0) & (y <= 27.0))
            z[idx] = 2.38
            idx = np.where((y > 27.0) & (y <= 28.0))
            z[idx] = 3.51
            idx = np.where((y > 28.0) & (y <= 29.0))
            z[idx] = 5.0
            idx = np.where((y > 29.0) & (y <= 30.0))
            z[idx] = 7.96
        except Exception as e:
            print(e)
        else:
            return z

model=Sequential()

model.add(Conv3D(input_shape=(3,32,32,32),data_format="channels_first",filters=32,kernel_size=5,strides=1,kernel_initializer='random_uniform',activation='relu',kernel_regularizer=regularizers.l2(0.0005)))
model.add(Conv3D(data_format="channels_first",filters=32,kernel_size=5,strides=1,kernel_initializer='random_uniform',activation='relu',kernel_regularizer=regularizers.l2(0.0005)))
model.add(MaxPooling3D())
model.add(Dropout(0.2))

model.add(Conv3D(data_format="channels_first",filters=64,kernel_size=3,strides=1,kernel_initializer='random_uniform',activation='relu',kernel_regularizer=regularizers.l2(0.0005)))
model.add(Conv3D(data_format="channels_first",filters=64,kernel_size=3,strides=1,kernel_initializer='random_uniform',activation='relu',kernel_regularizer=regularizers.l2(0.0005)))
model.add(Dropout(0.2))

model.add(Flatten())

model.add(Dense(256,activation='relu',kernel_regularizer=regularizers.l2(0.0005)))
model.add(Dropout(0.5))

model.add(Dense(1,activation='linear'))

sgd = SGD(lr=0.01)

model.compile(loss='mean_squared_error', optimizer=sgd, metrics=['mae'])

model.summary()

early_stopping = EarlyStopping(monitor='val_loss', patience=30)
checkpoint = ModelCheckpoint(filepath=cppath+'weights.{epoch:03d}-{val_loss:.6f}.hdf5')
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, verbose=1, patience=5, min_lr=0.00001, min_delta=0.0)
csv_logger = CSVLogger(modelpath+'log.csv')

hist = model.fit_generator(tSequence(datapath, VoxelPrg, listpath, tbatchsize, tsteps), steps_per_epoch=tsteps, epochs=400, validation_data=vSequence(datapath, VoxelPrg, listpath, vbatchsize, vsteps), validation_steps=vsteps, callbacks=[early_stopping, checkpoint, reduce_lr, csv_logger], workers=10, use_multiprocessing=True)
